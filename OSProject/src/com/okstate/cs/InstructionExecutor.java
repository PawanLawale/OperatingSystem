package com.okstate.cs;

import java.util.ArrayList;

/**
 * @author : Pawan Lawale
 * @Date : 25-Feb-2014
 * 
 * @Routine : InstructionExecutor
 *	1. Description:
 *			This routine is to execute the instruction as per the Op Code sent to it.
 *			It executes both One Address and Zero Address instructions.
 *
 *	2. Global Variables:
 *			a. systemClock :
 *					This is a virtual system clock measured in virtual time units.
 *			b. output:
 *					Its a list of all the output generated by the instructions to be shown on the screen.
 *			
 */

public class InstructionExecutor{
	
	public static int systemClock = 0;
	public static int totalIoTime = 0;
	public static ArrayList<String> output = new ArrayList<String>();
	
	/*
	 * This method executes the valid zero address Op Codes.
	 * If invalid Op Code is passed, it throws ERROR message.
	 */
	public static boolean zeroAddressInstrutions(String opCode) throws ErrorHandler{
		boolean flag = true;
		String value1 = null;
		String value2 = null;
		String result = null;
		int dec1 = 0;
		int dec2 = 0;
		int code = Integer.parseInt(opCode, 2);
		switch(code){
			case 0://NOP
				break;
				
			case 1://OR
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().pop();
				result = Utility.binaryLogicalOperation(value1, value2, code);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 2://AND
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().pop();
				result = Utility.binaryLogicalOperation(value1, value2, code);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 3://NOT
				value1 = CPU.getStack().pop();
				result = Utility.binaryLogicalOperation(value1, null, code);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 4://XOR
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().pop();
				result = Utility.binaryLogicalOperation(value1, value2, code);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 5://ADD
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().pop();
				result = Utility.binaryAddition(value1, value2, 16);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 6://SUB
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().pop();
				result = Utility.binarySubtraction(value2, value1);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 7://MUL
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().pop();
				result = Utility.binaryMultipilcation(value1, value2);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 8://DIV
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().pop();
				result = Utility.binaryDivision(value2, value1);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 9://MOD
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().pop();
				result = Utility.binaryMod(value2, value1);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 10://SL
				value1 = CPU.getStack().pop();
				dec1 = Integer.parseInt(value1,2) << 1;
				result = Utility.decimalToBinary(dec1, 16);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 11://SR
				value1 = CPU.getStack().pop();
				dec1 = Integer.parseInt(value1,2) >> 1;
				result = Utility.decimalToBinary(dec1, 16);
				CPU.getStack().push(result);
				systemClock++;
				break;
				
			case 12://CPG
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().valueAtTOS();
				if(value2 == null || value2.equals("")){
					throw new ErrorHandler(104);
				}
				dec1 = (short)Integer.parseInt(value1,2);
				dec2 = (short)Integer.parseInt(value2,2);
				if(dec2 > dec1){
					CPU.getStack().push("1111111111111111");
				}else{
					CPU.getStack().push("0000000000000000");
				}
				systemClock++;
				break;
				
			case 13://CPL
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().valueAtTOS();
				if(value2 == null || value2.equals("")){
					throw new ErrorHandler(104);
				}
				dec1 = (short)Integer.parseInt(value1,2);
				dec2 = (short)Integer.parseInt(value2,2);
				if(dec2 < dec1){
					CPU.getStack().push("1111111111111111");
				}else{
					CPU.getStack().push("0000000000000000");
				}
				systemClock++;
				break;
				
			case 14://CPE
				value1 = CPU.getStack().pop();
				value2 = CPU.getStack().valueAtTOS();
				if(value2 == null || value2.equals("")){
					throw new ErrorHandler(104);
				}
				dec1 = (short)Integer.parseInt(value1,2);
				dec2 = (short)Integer.parseInt(value2,2);
				if(dec2 == dec1){
					CPU.getStack().push("1111111111111111");
				}else{
					CPU.getStack().push("0000000000000000");
				}
				systemClock++;
				break;
				
			case 19://RD
				try{
					System.out.print("I: ");
					value1 = OperatingSystem.readInput();
					dec1 = Integer.parseInt(value1);
					if(dec1 < 8192 && dec1 >= -8192){
						value2 = Utility.decimalToBinary(dec1,16);
						CPU.getStack().push(value2);
					}else{
						//Value out of bound exception.
						throw new ErrorHandler(105);
					}
				}catch(NumberFormatException e){
					throw new ErrorHandler(102);
				}catch(ErrorHandler e){
					throw e;
				}
				systemClock += 15;
				totalIoTime += 15;
				break;
				
			case 20://WR
				value1 = CPU.getStack().pop();
				if((short)Integer.parseInt(value1, 2)> 8191 || (short)Integer.parseInt(value1, 2) < -8192){
					System.out.println("WARNING: Potential Loss of bits");
					ErrorHandler.warningMessages.add("WARNING: Potential Loss of bits");
				}
				if(value1.charAt(0)=='1'){
					StringBuilder temp = new StringBuilder(value1);
					for(int i=0;i<3;i++){
						temp.setCharAt(i, '1');
					}
					value1 = temp.toString();
				}else{
					StringBuilder temp = new StringBuilder(value1);
					for(int i=0;i<3;i++){
						temp.setCharAt(i, '0');
					}
					value1 = temp.toString();
				}
				System.out.println("O: "+(short)Integer.parseInt(value1, 2));
				output.add((short)Integer.parseInt(value1, 2)+"");
				systemClock += 15;
				totalIoTime += 15;
				break;
				
			case 21://RTN
				value1 = CPU.getStack().pop();
				CPU.setProgramCounter(value1);
				systemClock++;
				break;
				
			case 24://HLT
				flag = false;
				System.out.println("O: END");
				systemClock++;
				break;
				
			default:
				flag = false;
				//Raise exception of Invalid Op Code
				throw new ErrorHandler(113);
		}
		return flag;
	}
	
	/*
	 * This method executes the valid one address Op Codes.
	 * If invalid Op Code is passed, it throws ERROR message.
	 */
	public static boolean oneAddressInstrutions(String opCode,String effectiveAddress,String actualAddress,String jobId,MemoryManager memoryManager) throws ErrorHandler{
		boolean flag = true;
		String value1 = null;
		String result = null;
		int dec1 = 0;
		int dec2 = 0;
		String valueAtAddress = "";
		int code = Integer.parseInt(opCode, 2);
		switch(code){
			case 0://NOP
				break;
				
			case 1://OR
				value1 = CPU.getStack().pop();
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				result = Utility.binaryLogicalOperation(value1, valueAtAddress, code);
				CPU.getStack().push(result);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 2://AND
				value1 = CPU.getStack().pop();
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				result = Utility.binaryLogicalOperation(value1, valueAtAddress, code);
				CPU.getStack().push(result);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 4://XOR
				value1 = CPU.getStack().pop();
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				result = Utility.binaryLogicalOperation(value1, valueAtAddress, code);
				CPU.getStack().push(result);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 5://ADD
				value1 = CPU.getStack().pop();
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				result = Utility.binaryAddition(value1, valueAtAddress, 16);
				CPU.getStack().push(result);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 6://SUB
				value1 = CPU.getStack().pop();
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				result = Utility.binarySubtraction(value1, valueAtAddress);
				CPU.getStack().push(result);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 7://MUL
				value1 = CPU.getStack().pop();
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				result = Utility.binaryMultipilcation(value1, valueAtAddress);
				CPU.getStack().push(result);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 8://DIV
				value1 = CPU.getStack().pop();
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				result = Utility.binaryDivision(value1, valueAtAddress);
				CPU.getStack().push(result);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 9://MOD
				value1 = CPU.getStack().pop();
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				result = Utility.binaryMod(value1, valueAtAddress);
				CPU.getStack().push(result);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 12://CPG
				value1 = CPU.getStack().valueAtTOS();
				if(value1 == null || value1.equals("")){
					throw new ErrorHandler(104);
				}
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				dec1 = (short)Integer.parseInt(value1,2);
				dec2 = (short)Integer.parseInt(valueAtAddress,2);
				if(dec1 > dec2){
					CPU.getStack().push("1111111111111111");
				}else{
					CPU.getStack().push("0000000000000000");
				}
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 13://CPL
				value1 = CPU.getStack().valueAtTOS();
				if(value1 == null || value1.equals("")){
					throw new ErrorHandler(104);
				}
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				dec1 = (short)Integer.parseInt(value1,2);
				dec2 = (short)Integer.parseInt(valueAtAddress,2);
				if(dec1 < dec2){
					CPU.getStack().push("1111111111111111");
				}else{
					CPU.getStack().push("0000000000000000");
				}
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 14://CPE
				value1 = CPU.getStack().valueAtTOS();
				if(value1 == null || value1.equals("")){
					throw new ErrorHandler(104);
				}
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				dec1 = (short)Integer.parseInt(value1,2);
				dec2 = (short)Integer.parseInt(valueAtAddress,2);
				if(dec2 == dec1){
					CPU.getStack().push("1111111111111111");
				}else{
					CPU.getStack().push("0000000000000000");
				}
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 15://BR
				CPU.setProgramCounter(effectiveAddress);
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				break;
				
			case 16://BRT
				value1 = CPU.getStack().pop();
				if(value1.equals("1111111111111111")){
					CPU.setProgramCounter(effectiveAddress);
				}else{
					CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				}
				break;
				
			case 17://BRF
				value1 = CPU.getStack().pop();
				if(value1.equals("0000000000000000")){
					CPU.setProgramCounter(effectiveAddress);
				}else{
					CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				}
				break;
				
			case 18://CALL
				CPU.getStack().push(String.format("%16s", CPU.getProgramCounter()).replace(" ", "0"));
				CPU.setProgramCounter(effectiveAddress);
				break;
				
			case 22://PUSH
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				CPU.getStack().push(valueAtAddress);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				break;
				
			case 23://POP
				value1 = CPU.getStack().pop();
				Memory.loadProgram(actualAddress, value1);
				CPU.setProgramCounter(Utility.binaryAddition(CPU.getProgramCounter(), "00000001", 8));
				valueAtAddress = memoryManager.getInstructionAtLocation(jobId, actualAddress);
				break;
				
			default:
				flag = false;
				//Raise exception of Invalid Op Code
				throw new ErrorHandler(113);
		}
		systemClock += 4;
		return flag;
	}
	
}
